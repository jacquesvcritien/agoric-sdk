import { Command } from 'commander';
import { inspect } from 'util';
import {
  boardSlottingMarshaller,
  makeRpcUtils,
  storageHelper,
  networkConfig
} from '../lib/rpc.js';
import {
    makeFollower,
    makeLeader,
  } from '@agoric/casting';
import { coalesceWalletState } from '@agoric/smart-wallet/src/utils.js';
import { readFile, saveState } from './helper.js'

import { getCurrent } from '../lib/wallet.js';

const { agoricNames, fromBoard, vstorage } = await makeRpcUtils({ fetch });

var feeds = []

const { PORT = '3000', POLL_INTERVAL = '10' } = process.env;
assert(!isNaN(Number(PORT)), '$PORT is required');
assert(!isNaN(Number(POLL_INTERVAL)), '$POLL_INTERVAL is required');
const STATE_FILE = "monitoring_state.json"

const readOracleAddresses = () => {
    var fileInput = readFile("oracles.txt")
    var addresses = fileInput.split(",")
    var oracles = {}
    for (let addr of addresses) {
      addr = addr.replaceAll("\n", "")
      oracles[addr] = {}
    }
    return oracles
}

var oracles = readOracleAddresses();

export const getLatestPrices = async (oracle, feeds, last_index) => {

    console.log("Getting prices for", oracle, feeds)

    const unserializer = boardSlottingMarshaller(fromBoard.convertSlotToVal);

    const leader = makeLeader(networkConfig.rpcAddrs[0]);

    const follower = await makeFollower(
        `:published.wallet.${oracle}`,
        leader,
        {
            // @ts-expect-error xxx
            unserializer,
        },
    );
    const coalesced = await coalesceWalletState(follower);
    let offers = Array.from(coalesced.offerStatuses.values());

    let last_results = {
        "last_index": last_index,
        "values": {}
    }

    for (var i=last_index; i<offers.length; i++){
        var current_offer = offers[i];
        last_results["last_index"] = i;
        last_results["values"][feeds[current_offer["invitationSpec"]["previousOffer"]]] = Number(current_offer["invitationSpec"]["invitationArgs"]);
    }
    console.log(last_results)
}

export const getOraclesInvitations = async() => {
    for (let key in agoricNames.instance) {
        if(key.includes("price feed")){
            let feed = key.split(" price feed")[0]
            let boardId = agoricNames.instance[key].boardId
            feeds.push({
                feed: feed,
                boardId: boardId
            })
        }
    }
    feeds = agoricNames.reverse

    for (let oracle in oracles){

        const current = await getCurrent(oracle, fromBoard, {
            vstorage,
        });

        const invitations = current.offerToUsedInvitation
 

        for (let inv in invitations) {

           let boardId = invitations[inv].value[0].instance.boardId
           let feed = feeds[boardId].split(" price feed")[0]
           oracles[oracle][String(inv)] = feed
        }
    }

    
    console.log(oracles)
}

const readMonitoringState = () => {
    try{
        return readJSONFile(STATE_FILE)
    }catch {
        let initial_state = {}

        for (let oracle in oracles){
            initial_state[oracle] = {}
        }

        saveState(initial_state, STATE_FILE)
        return initial_state
    }
}

export const monitor = async() => {

    let state = readMonitoringState()
    console.log(state)
    setInterval(async () => {

        
        //for each oracle
        for (let oracle in oracles){

            //check if there is state for oracle
            if (!state[oracle]){
                state[oracle] = {
                    "last_index": 0,
                    "values": {}
                }
            }

            console.log(state[oracle])

            let latest_oracle_state = await getLatestPrices(oracle, oracles[oracle], state[oracle]["last_index"])
            state[oracle] = latest_oracle_state
        }

        saveState(state, STATE_FILE)

        // const result = await E(roundNotifier).getUpdateSince(updateCount)
        // updateCount = result.updateCount;

        // //get aggregated value
        // results["actual"] = (Number(result.value.authenticatedQuote.quoteAmount.value[0].amountOut.value)*1.0) / Number(result.value.authenticatedQuote.quoteAmount.value[0].amountIn.value)

        // var observations = result.value.submitted
    
        // //for each observation
        // for(var i=0; i<observations.length; i++){
        //     var obs = observations[i]
        //     var submitter = obs[0]
        //     var value = (Number(obs[1].numerator.value)*1.0) / Number(obs[1].denominator.value)
        //     results[submitter] = Number(value)
        // }
        // console.log("Results", results)

        // var filename = ASSET_IN+"-"+ASSET_OUT+".json"
    
        // await fs.writeFileSync(filename, JSON.stringify(results), 'utf8')
        
    }, POLL_INTERVAL*1000);
}
